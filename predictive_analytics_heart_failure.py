# -*- coding: utf-8 -*-
"""Predictive Analytics Heart Failure.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hzfDkfmqnrI_JDwHwxlXKh2gVJeJkEBW

# Proyek Predictive Analytics: Heart Failure
- **Nama:** Syahran Fadhil Dafanindra
- **Email:** fadhilrafa1@gmail.com
- **ID Dicoding:** syahran_fadhil_d

# Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
# Library untuk pengolahan data
import numpy as np
import pandas as pd
from google.colab import files

# Library untuk visualisasi
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

# Library untuk pre-processing dan splitting data
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.model_selection import train_test_split

# Library untuk pemodelan dan evaluasi
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import mean_squared_error, accuracy_score, confusion_matrix, classification_report

"""# Data Loading

## Download dataset dari kaggle
"""

!kaggle datasets download -d fedesoriano/heart-failure-prediction

"""## Ekstrak dataset zip yang sudah didownload"""

!unzip heart-failure-prediction.zip

"""## Memuat data dari file csv ke dataframe"""

hearts = pd.read_csv('heart.csv')

"""# Data Understanding
1. Age: usia pasien [tahun]
2. Sex: jenis kelamin pasien [M: Male, F: Female]
3. ChestPainType: tipe nyeri dada:
   - TA: Typical Angina
   - ATA: Atypical Angina
   - NAP: Non-Anginal Pain
   - ASY: Asymptomatic
4. RestingBP: tekanan darah istirahat [mm Hg]
5. Cholesterol: kolesterol serum [mm/dl]
6. FastingBS: gula darah puasa [1: jika FastingBS > 120 mg/dl, 0: sebaliknya]
7. RestingECG: hasil elektrokardiogram istirahat:
   - Normal: Normal
   - ST: memiliki kelainan gelombang ST-T
   - LVH: menunjukkan kemungkinan atau pasti hipertrofi ventrikel kiri
8. MaxHR: detak jantung maksimum yang dicapai [Numeric value between 60 and 202]
9. ExerciseAngina: angina yang diinduksi oleh olahraga [Y: Yes, N: No]
10. Oldpeak: depresi ST yang diinduksi oleh olahraga relatif terhadap istirahat [Numeric value measured in depression]
11. ST_Slope: kemiringan segmen ST latihan puncak:
    - Up: upsloping
    - Flat: flat
    - Down: downsloping
12. HeartDisease: kelas output [1: heart disease, 0: Normal]
"""

# menampilkan 5 baris pertama dalam dataframe
hearts.head()

# menampilkan struktur dari setiap fitur di dataframe
hearts.info()

# menampilkan gambaran umum untuk fitur numerik
hearts.describe()

# mengecek missing value dari dataframe
hearts.isnull().sum()

# memisahkan antara fitur numerik dengan categorical/object
numerical_feature = ['Age', 'RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']
categorical_feature = ['Sex', 'ChestPainType', 'FastingBS', 'RestingECG', 'ExerciseAngina', 'ST_Slope']

"""## Visualisasi Categorical Features"""

# menampilkan visualisasi distribusi setiap fitur kategorikal
for feature in categorical_feature:
    count = hearts[feature].value_counts()
    percent = 100 * hearts[feature].value_counts(normalize=True)
    df = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})

    print(f"\nFeature: {feature}")
    print(df)

    count.plot(kind='bar', title=feature)
    plt.ylabel("Count")
    plt.xlabel(feature)
    plt.show()

"""## Visualisasi Numerical Features

Setelah menganalisa visualisasi dalam fitur numerik, terlihat bahwa fitur RestingBP dan Cholesterol memiliki value 0 yang dimana ini merupakan kesalahan pencatatan dalam data.
"""

# Menampilkan histogram setiap fitur numerik
for feature in numerical_feature:
    # Menampilkan histogram
    plt.figure(figsize=(8, 6))
    sns.histplot(hearts[feature], kde=True)
    plt.title(f'Histogram of {feature}')
    plt.xlabel(feature)
    plt.ylabel("Frequency")
    plt.tight_layout()

    mean_val = hearts[feature].mean()
    median_val = hearts[feature].median()
    std_dev = hearts[feature].std()
    print(f"Feature '{feature}':")
    print(f"  - Rata-rata: {mean_val:.2f}")
    print(f"  - Median: {median_val:.2f}")
    print(f"  - Standar deviasi: {std_dev:.2f}")


    plt.show()

"""# Data Pre-processing

## Menangani Value Tidak Valid

diketahui pada analisa data sebelumnya bahwa fitur RestingBP dan Cholesterol memiliki value 0 yang dimana data itu tidak valid
"""

# Mengganti nilai 0 di RestingBP dan Cholesterol menjadi NaN
hearts['RestingBP'] = hearts['RestingBP'].replace(0, np.nan)
hearts['Cholesterol'] = hearts['Cholesterol'].replace(0, np.nan)

# Menampilkan missing value dari semua fitur
print(hearts.isnull().sum())

# Mengubah nilai NaN di fitur RestingBP dan Cholesterol menjadi median
hearts['RestingBP'].fillna(hearts['RestingBP'].median(), inplace=True)
hearts['Cholesterol'].fillna(hearts['Cholesterol'].median(), inplace=True)

# Menampilkan missing value dari semua fitur setelah penggantian
print(hearts.isnull().sum())

"""## Menangani Outlier"""

# Visualisasi Boxplot untuk mendeteksi outlier pada fitur numerik
for feature in numerical_feature:
  plt.figure(figsize=(8, 6))
  sns.boxplot(x=hearts[feature])
  plt.title(f"Boxplot of {feature}")
  plt.show()

# Fungsi untuk mendeteksi dan menangani outlier menggunakan IQR
def handle_outliers_iqr(df, feature):
  Q1 = df[feature].quantile(0.25)
  Q3 = df[feature].quantile(0.75)
  IQR = Q3 - Q1
  lower_bound = Q1 - 1.5 * IQR
  upper_bound = Q3 + 1.5 * IQR

  df[feature] = np.where(df[feature] < lower_bound, lower_bound, df[feature])
  df[feature] = np.where(df[feature] > upper_bound, upper_bound, df[feature])

  return df

# Menangani outlier pada fitur numerik menggunakan IQR
for feature in numerical_feature:
  hearts = handle_outliers_iqr(hearts, feature)

# Menampilkan boxplot setelah penanganan outlier
for feature in numerical_feature:
  plt.figure(figsize=(8, 5))
  sns.boxplot(x=hearts[feature])
  plt.title(f"Boxplot of {feature} after outlier handling")
  plt.show()

"""## Data Splitting / Pemisahan
- membagi dataset menjadi 2 bagian, data test dan data latih

- menggunakan proporsi 80:20
"""

# membagi dataset menjadi data test dan data latih
X = hearts.drop(["HeartDisease"],axis =1)
y = hearts["HeartDisease"]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 123)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""## One-Hot Encoding

- mengubah fitur kategorikal menjadi numerik yang bernilai 1 dan 0

- untuk mempercepat algoritma machine learning dalam memproses data

- menghilangkan fitur kategorikal setelah diencode
"""

# Melakukan one-hot encoding untuk setiap fitur kategorikal dan menggabungkannya ke dalam dataframe
for feature in categorical_feature:
    X_train = pd.concat([X_train, pd.get_dummies(X_train[feature], prefix=feature)], axis=1)
    X_test = pd.concat([X_test, pd.get_dummies(X_test[feature], prefix=feature)], axis=1)

# Menghapus fitur kategorikal asli setelah di-encode
X_train.drop(categorical_feature, axis=1, inplace=True)
X_test.drop(categorical_feature, axis=1, inplace=True)

# Menampilkan hasil
X_train.head()

"""## Standarisasi Data
- menghasilkan distribusi dengan standar deviasi sama dengan 1 dan mean sama dengan 0. Sekitar 68% dari nilai akan berada di antara -1 dan 1.

- untuk mempercepat algoritma machine learning dalam memproses data

- hanya untuk data numerik
"""

# Mendefinisikan dan menstandarisasi data latih serta data uji sekaligus
scaler = StandardScaler()

# Menstandarisasi data latih dan data uji tanpa menimbulkan data leakage
X_train[numerical_feature] = scaler.fit_transform(X_train[numerical_feature])
X_test[numerical_feature] = scaler.transform(X_test[numerical_feature])

X_train[numerical_feature].head()

X_train[numerical_feature].describe().round(4)

"""# Model Development

## KNN (K-Nearest Neighbor)

- melatih model KNN

- menggunakan k = 10 tetangga
"""

knn = KNeighborsClassifier(n_neighbors=10)
knn.fit(X_train, y_train)

"""## Random Forest

- n_estimator: jumlah trees (pohon) di forest.

- max_depth: kedalaman atau panjang pohon. Ia merupakan ukuran seberapa banyak pohon dapat membelah (splitting).

- random_state: digunakan untuk mengontrol random number generator yang digunakan.

- n_jobs: jumlah job (pekerjaan) yang digunakan secara paralel. n_jobs=-1 artinya semua proses berjalan secara paralel.
"""

RF = RandomForestClassifier(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

"""# Evaluasi Model"""

# Melakukan prediksi pada data uji menggunakan model KNN dan Random Forest
knn_pred = knn.predict(X_test)
rf_pred = RF.predict(X_test)

# Menghitung akurasi model KNN
accuracy_knn = accuracy_score(y_test, knn_pred)
print("Akurasi KNN:", accuracy_knn)

# Menghitung akurasi model Random Forest
accuracy_rf = accuracy_score(y_test, rf_pred)
print("Akurasi Random Forest:", accuracy_rf)

# Membuat classification report untuk model KNN
print("Classification Report untuk KNN:")
print(classification_report(y_test, knn_pred))

# Membuat classification report untuk model Random Forest
print("Classification Report untuk Random Forest:")
print(classification_report(y_test, rf_pred))